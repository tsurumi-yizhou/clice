import{_ as i,c as a,o as s,ae as n}from"./chunks/framework.l7bN90nj.js";const h=JSON.parse('{"title":"Compilation","description":"","frontmatter":{},"headers":[],"relativePath":"fr/design/compilation.md","filePath":"fr/design/compilation.md"}'),t={name:"fr/design/compilation.md"};function l(r,e,o,c,p,d){return s(),a("div",null,[...e[0]||(e[0]=[n(`<h1 id="compilation" tabindex="-1">Compilation <a class="header-anchor" href="#compilation" aria-label="Permalink to &quot;Compilation&quot;">​</a></h1><h2 id="analyse-incrementale" tabindex="-1">Analyse Incrémentale <a class="header-anchor" href="#analyse-incrementale" aria-label="Permalink to &quot;Analyse Incrémentale&quot;">​</a></h2><p>Chaque fois que vous modifiez du code, clice doit ré-analyser le fichier. clice utilise un mécanisme appelé &quot;préambule&quot; pour implémenter la compilation incrémentale afin d&#39;accélérer la ré-analyse. Le préambule peut être considéré comme un cas particulier d&#39;un <a href="https://clang.llvm.org/docs/PCHInternals.html" target="_blank" rel="noreferrer">En-tête Précompilé</a> (PCH) intégré aux fichiers sources. Lors de l&#39;ouverture d&#39;un fichier, clice compile les premières directives du préprocesseur au début du fichier (appelées préambule) dans un cache PCH sur le disque. Plus tard, lors de l&#39;analyse, il peut charger directement le fichier PCH, sautant ainsi les premières directives, ce qui réduit considérablement la quantité de code à ré-analyser.</p><p>Par exemple, pour le code suivant :</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello world!&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Le fichier d&#39;en-tête <code>iostream</code> contient environ 20 000 lignes de code. clice va d&#39;abord compiler la ligne <code>#include &lt;iostream&gt;</code> dans un fichier PCH, et une fois terminé, utiliser ce fichier PCH pour analyser le code suivant. De cette façon, la quantité de code à ré-analyser ultérieurement est réduite à seulement 5 lignes au lieu des 20 000 lignes originales, ce qui rend l&#39;opération très rapide. Sauf si vous modifiez le code dans la section du préambule, ce qui nécessiterait la construction d&#39;un nouveau préambule.</p>`,6)])])}const m=i(t,[["render",l]]);export{h as __pageData,m as default};
