import{_ as s,c as a,o as r,ae as t}from"./chunks/framework.l7bN90nj.js";const m=JSON.parse(`{"title":"Qu'est-ce que clice ?","description":"","frontmatter":{},"headers":[],"relativePath":"fr/guide/what-is-clice.md","filePath":"fr/guide/what-is-clice.md"}`),n={name:"fr/guide/what-is-clice.md"};function i(o,e,u,l,c,d){return r(),a("div",null,[...e[0]||(e[0]=[t('<h1 id="qu-est-ce-que-clice" tabindex="-1">Qu&#39;est-ce que clice ? <a class="header-anchor" href="#qu-est-ce-que-clice" aria-label="Permalink to &quot;Qu&#39;est-ce que clice ?&quot;">​</a></h1><p>clice est un serveur de langage C++ entièrement nouveau, né de la volonté de transcender les limites des solutions actuelles. Plus qu&#39;un simple outil, il aspire à offrir une navigation fluide et une intelligence de code véritablement au service du développeur.</p><h2 id="pourquoi-un-nouveau-serveur-de-langage" tabindex="-1">Pourquoi un nouveau serveur de langage ? <a class="header-anchor" href="#pourquoi-un-nouveau-serveur-de-langage" aria-label="Permalink to &quot;Pourquoi un nouveau serveur de langage ?&quot;">​</a></h2><p>Une question s&#39;impose d&#39;emblée : pourquoi se lancer dans le développement d&#39;un nouveau serveur de langage ? Est-il vraiment nécessaire de « réinventer la roue » ?</p><p>C&#39;est une interrogation qui mérite une réponse sincère. Avant d&#39;initier ce projet, j&#39;ai conçu de nombreux programmes, des plus modestes aux plus ambitieux. Mais, pour être honnête, la grande majorité n&#39;était que des « projets jouets » — des exercices de style pour valider une idée ou approfondir un apprentissage, sans jamais s&#39;attaquer à un problème concret. clice boxe dans une autre catégorie. Il ne s&#39;agit pas d&#39;une réécriture pour le plaisir du code, mais d&#39;une tentative authentique de résoudre les impasses techniques auxquelles nous sommes tous confrontés.</p><p>Au début de cette année, j&#39;avais l&#39;ambition de contribuer au projet LLVM. Je voulais m&#39;immerger dans ce que je maîtrise le mieux : le C++, et plus spécifiquement Clang. Mais sans objectif précis, on finit vite par fixer le code source sans trop savoir par où l&#39;empoigner. Le parcours classique consiste à s&#39;attaquer à quelques « first issues » pour apprivoiser le projet. Pour moi, c&#39;était d&#39;un ennui mortel. Je voulais m&#39;attaquer à un défi de taille, comme l&#39;implémentation d&#39;une nouvelle fonctionnalité du standard C++. J&#39;ai vite réalisé que les portes étaient fermées : ces développements majeurs sont la chasse gardée de quelques architectes de Clang. Puisque l&#39;opportunité manquait là-bas, j&#39;ai tourné mon regard vers clangd. Développant principalement sous VSCode, clangd était pour moi la référence incontournable.</p><p>À l&#39;époque, j&#39;ignorais tout de ses entrailles, si ce n&#39;est qu&#39;il peinait parfois sur la coloration syntaxique de certains mots-clés. J&#39;ai donc commencé à plonger dans son code source, tout en épluchant ses innombrables <em>issues</em> pour trouver un terrain où me rendre utile. C&#39;est là que j&#39;ai découvert l&#39;ampleur du chantier. Un sujet a particulièrement piqué ma curiosité : la complétion de code au sein des templates (<a href="https://github.com/clangd/clangd/issues/443" target="_blank" rel="noreferrer">issue #443</a>). Ceux qui me suivent savent que je suis un passionné de métaprogrammation, et j&#39;étais avide de comprendre comment Clang gérait ces mécanismes en interne. Après des semaines de recherche et de prototypage, j&#39;ai fini par proposer une solution. <strong>Et c&#39;est là que j&#39;ai fait une découverte stupéfiante : il n&#39;y avait absolument personne pour réviser mon code !</strong></p><p>En creusant davantage, j&#39;ai réalisé que la situation de clangd était alarmante. Pour comprendre, il faut regarder en arrière : clangd n&#39;était au départ qu&#39;un modeste projet satellite au sein de LLVM, loin d&#39;être la référence en termes de fonctionnalités. Comme le soulignait MaskRay dans son <a href="https://maskray.me/blog/2017-12-03-c++-language-server-cquery" target="_blank" rel="noreferrer">blog</a> à propos de ccls, clangd ne gérait alors que des unités de compilation isolées. En 2017, ccls était d&#39;ailleurs bien plus robuste. Puis, Google a investi massivement dans clangd pour ses propres besoins internes. Le projet a alors décollé, suivant les évolutions du protocole LSP, tandis que l&#39;auteur de ccls s&#39;éloignait vers d&#39;autres horizons. Vers 2023, le vent a tourné : clangd a atteint un stade jugé suffisant pour les besoins de Google, et les ingénieurs dédiés ont été réaffectés. Aujourd&#39;hui, le projet repose presque entièrement sur les épaules d&#39;une seule personne, <a href="https://github.com/HighCommander4" target="_blank" rel="noreferrer">HighCommander4</a>, qui s&#39;y consacre par pure passion, sur son temps libre, sans aucun soutien institutionnel. Il se retrouve à gérer seul un flux incessant de questions et de corrections, comme il le confiait lui-même dans ce <a href="https://github.com/clangd/clangd/issues/1690#issuecomment-1619735578" target="_blank" rel="noreferrer">commentaire</a> :</p><blockquote><p>« L&#39;autre raison est le manque de ressources pour explorer nos idées, comme celle de décharger davantage la mémoire vers le disque via une mise en cache plus agressive des préambules. Je suis un contributeur occasionnel, et le peu de temps que je peux consacrer à clangd est absorbé par l&#39;aide aux utilisateurs et quelques corrections mineures ; je n&#39;ai tout simplement pas la bande passante pour mener de telles expérimentations de performance. »</p></blockquote><p>Dans ce contexte, il n&#39;est pas surprenant que des chantiers colossaux, comme le <a href="https://github.com/llvm/llvm-project/pull/66462" target="_blank" rel="noreferrer">support préliminaire des modules C++20</a>, stagnent pendant près d&#39;un an. Ce constat a été le déclic : pourquoi ne pas créer mon propre serveur de langage ? J&#39;ai estimé qu&#39;avec environ 20 000 lignes de code (hors tests), le projet était à la portée d&#39;un développeur déterminé. Des succès comme ccls ou rust-analyzer prouvaient que l&#39;aventure était possible. De plus, le code de clangd commence à accuser son âge ; malgré les commentaires, sa logique est devenue si tortueuse qu&#39;une réécriture complète me semblait plus rapide et plus saine que d&#39;essayer de le réformer de l&#39;intérieur.</p><p>Alors, j&#39;ai sauté le pas. J&#39;ai analysé des centaines d&#39;issues pour identifier les problèmes structurels de clangd, ceux que son architecture initiale rendait impossibles à résoudre. Pouvait-on les éliminer dès la conception ? La réponse était oui. J&#39;ai passé deux mois à disséquer les mécanismes de Clang, à explorer des solutions fondamentales et à valider des prototypes. Une fois convaincu que le socle était solide, le développement de clice a officiellement commencé.</p>',11)])])}const g=s(n,[["render",i]]);export{m as __pageData,g as default};
