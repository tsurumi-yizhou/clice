import{_ as a,c as i,o as r,ae as o}from"./chunks/framework.l7bN90nj.js";const h=JSON.parse('{"title":"Démarrage Rapide","description":"","frontmatter":{},"headers":[],"relativePath":"fr/guide/quick-start.md","filePath":"fr/guide/quick-start.md"}'),t={name:"fr/guide/quick-start.md"};function s(n,e,l,c,d,u){return r(),i("div",null,[...e[0]||(e[0]=[o('<h1 id="demarrage-rapide" tabindex="-1">Démarrage Rapide <a class="header-anchor" href="#demarrage-rapide" aria-label="Permalink to &quot;Démarrage Rapide&quot;">​</a></h1><h2 id="extensions-d-editeur" tabindex="-1">Extensions d&#39;Éditeur <a class="header-anchor" href="#extensions-d-editeur" aria-label="Permalink to &quot;Extensions d&#39;Éditeur&quot;">​</a></h2><p>clice implémente le <a href="https://microsoft.github.io/language-server-protocol" target="_blank" rel="noreferrer">Language Server Protocol</a>. Tout éditeur prenant en charge ce protocole peut théoriquement fonctionner avec clice pour fournir des fonctionnalités telles que la <code>complétion de code</code>, les <code>diagnostics</code>, le <code>passage à la définition</code>, et plus encore.</p><p>Cependant, au-delà du protocole standard, clice prend également en charge certaines extensions de protocole. Pour une meilleure gestion de ces extensions et une meilleure intégration avec les éditeurs, l&#39;utilisation de plugins clice dans des éditeurs spécifiques est souvent un meilleur choix. La plupart d&#39;entre eux fonctionnent immédiatement et prennent en charge les extensions de protocole de clice.</p><h3 id="visual-studio-code" tabindex="-1">Visual Studio Code <a class="header-anchor" href="#visual-studio-code" aria-label="Permalink to &quot;Visual Studio Code&quot;">​</a></h3><h3 id="vim-neovim" tabindex="-1">Vim/Neovim <a class="header-anchor" href="#vim-neovim" aria-label="Permalink to &quot;Vim/Neovim&quot;">​</a></h3><h3 id="autres" tabindex="-1">Autres <a class="header-anchor" href="#autres" aria-label="Permalink to &quot;Autres&quot;">​</a></h3><p>D&#39;autres éditeurs n&#39;ont pas encore d&#39;extensions clice disponibles (les contributions sont les bienvenues !). Pour utiliser clice avec eux, veuillez installer clice vous-même et vous référer à la documentation de votre éditeur spécifique sur la façon d&#39;utiliser un serveur de langage.</p><h2 id="installation" tabindex="-1">Installation <a class="header-anchor" href="#installation" aria-label="Permalink to &quot;Installation&quot;">​</a></h2><p>Si votre plugin d&#39;éditeur gère le téléchargement de clice, vous pouvez ignorer cette étape.</p><h3 id="telecharger-le-binaire-precompile" tabindex="-1">Télécharger le binaire précompilé <a class="header-anchor" href="#telecharger-le-binaire-precompile" aria-label="Permalink to &quot;Télécharger le binaire précompilé&quot;">​</a></h3><p>Téléchargez la version binaire de clice via la page des Releases.</p><h3 id="construire-a-partir-des-sources" tabindex="-1">Construire à partir des sources <a class="header-anchor" href="#construire-a-partir-des-sources" aria-label="Permalink to &quot;Construire à partir des sources&quot;">​</a></h3><p>Construisez clice à partir des sources vous-même. Pour les étapes spécifiques, reportez-vous à <a href="./../dev/build">construction</a>.</p><h2 id="configuration-du-projet" tabindex="-1">Configuration du Projet <a class="header-anchor" href="#configuration-du-projet" aria-label="Permalink to &quot;Configuration du Projet&quot;">​</a></h2><p>Pour que clice comprenne correctement votre code (par exemple, pour trouver l&#39;emplacement des fichiers d&#39;en-tête), vous devez fournir à clice un fichier <code>compile_commands.json</code>, également connu sous le nom de <a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html" target="_blank" rel="noreferrer">base de données de compilation</a>. La base de données de compilation fournit les options de compilation pour chaque fichier source.</p><h3 id="cmake" tabindex="-1">CMake <a class="header-anchor" href="#cmake" aria-label="Permalink to &quot;CMake&quot;">​</a></h3><p>Pour les systèmes de construction utilisant CMake, ajoutez l&#39;option <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code> lors de la construction, par exemple :</p><div class="language-cmake vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmake</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span></span></code></pre></div><p>Cela générera un fichier <code>compile_commands.json</code> dans le répertoire <code>build</code>.</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Note : Cette option ne fonctionne que lorsque le générateur de CMake est défini sur Makefile ou Ninja. Pour les autres générateurs, cette option sera ignorée, ce qui signifie que la base de données de compilation ne pourra pas être générée.</p></div><h3 id="bazel" tabindex="-1">Bazel <a class="header-anchor" href="#bazel" aria-label="Permalink to &quot;Bazel&quot;">​</a></h3><p>Bazel n&#39;a pas de support natif pour générer une base de données de compilation. La solution recommandée est d&#39;utiliser <a href="https://github.com/hedronvision/bazel-compile-commands-extractor" target="_blank" rel="noreferrer">bazel-compile-commands-extractor</a>. Après l&#39;avoir configuré, vous pouvez générer <code>compile_commands.json</code> avec :</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bazel</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @hedron_compile_commands//:refresh_all</span></span></code></pre></div><h3 id="visual-studio" tabindex="-1">Visual Studio <a class="header-anchor" href="#visual-studio" aria-label="Permalink to &quot;Visual Studio&quot;">​</a></h3><p>TODO:</p><h3 id="makefile" tabindex="-1">Makefile <a class="header-anchor" href="#makefile" aria-label="Permalink to &quot;Makefile&quot;">​</a></h3><p>TODO:</p><h3 id="xmake" tabindex="-1">Xmake <a class="header-anchor" href="#xmake" aria-label="Permalink to &quot;Xmake&quot;">​</a></h3><h3 id="autres-1" tabindex="-1">Autres <a class="header-anchor" href="#autres-1" aria-label="Permalink to &quot;Autres&quot;">​</a></h3><p>Pour tout autre système de construction, vous pouvez essayer d&#39;utiliser <a href="https://github.com/rizsotto/Bear" target="_blank" rel="noreferrer">bear</a> ou <a href="https://github.com/rizsotto/scan-build" target="_blank" rel="noreferrer">scan-build</a> pour intercepter les commandes de compilation et obtenir la base de données de compilation (sans garantie de succès). Nous prévoyons d&#39;écrire un <strong>nouvel outil</strong> à l&#39;avenir qui capturera les commandes de compilation via une approche de faux compilateur.</p>',31)])])}const m=a(t,[["render",s]]);export{h as __pageData,m as default};
