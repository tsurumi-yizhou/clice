import{_ as i,c as a,o as s,ae as n}from"./chunks/framework.l7bN90nj.js";const h=JSON.parse('{"title":"Compilation","description":"","frontmatter":{},"headers":[],"relativePath":"fr/design/compilation.md","filePath":"fr/design/compilation.md"}'),t={name:"fr/design/compilation.md"};function l(r,e,o,c,p,d){return s(),a("div",null,[...e[0]||(e[0]=[n(`<h1 id="compilation" tabindex="-1">Compilation <a class="header-anchor" href="#compilation" aria-label="Permalink to &quot;Compilation&quot;">​</a></h1><h2 id="analyse-incrementale" tabindex="-1">Analyse Incrémentale <a class="header-anchor" href="#analyse-incrementale" aria-label="Permalink to &quot;Analyse Incrémentale&quot;">​</a></h2><p>Chaque fois que vous modifiez du code, clice doit ré-analyser le fichier. clice utilise un mécanisme appelé « préambule » pour implémenter la compilation incrémentale afin d’accélérer la ré-analyse. Le préambule peut être considéré comme un cas particulier d’un <a href="https://clang.llvm.org/docs/PCHInternals.html" target="_blank" rel="noreferrer">en-tête précompilé</a> (PCH) intégré aux fichiers sources. Lors de l’ouverture d’un fichier, clice compile les premières directives du préprocesseur au début du fichier (appelées préambule) dans un cache PCH sur le disque. Plus tard, lors de l’analyse, il peut charger directement le fichier PCH, sautant ainsi les premières directives, ce qui réduit considérablement la quantité de code à ré-analyser.</p><p>Par exemple, pour le code suivant :</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;iostream&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello world!&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::endl;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Le fichier d’en-tête <code>iostream</code> contient environ 20 000 lignes de code. clice va d’abord compiler la ligne <code>#include &lt;iostream&gt;</code> dans un fichier PCH, et une fois terminé, utiliser ce fichier PCH pour analyser le code suivant. De cette façon, la quantité de code à ré-analyser ultérieurement est réduite à seulement 5 lignes au lieu des 20 000 lignes originales, ce qui rend l’opération très rapide. Sauf si vous modifiez le code dans la section du préambule, ce qui nécessiterait la construction d’un nouveau préambule.</p>`,6)])])}const m=i(t,[["render",l]]);export{h as __pageData,m as default};
