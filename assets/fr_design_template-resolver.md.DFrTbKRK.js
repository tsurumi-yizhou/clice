import{_ as s,c as i,o as a,ae as t}from"./chunks/framework.l7bN90nj.js";const u=JSON.parse('{"title":"Résolveur de Template","description":"","frontmatter":{},"headers":[],"relativePath":"fr/design/template-resolver.md","filePath":"fr/design/template-resolver.md"}'),n={name:"fr/design/template-resolver.md"};function l(p,e,r,o,d,c){return a(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="resolveur-de-template" tabindex="-1">Résolveur de Template <a class="header-anchor" href="#resolveur-de-template" aria-label="Permalink to &quot;Résolveur de Template&quot;">​</a></h1><p>Tout d&#39;abord, il y a un meilleur support des templates, ce qui est aussi la fonctionnalité que je voulais initialement que clangd prenne en charge. Plus précisément, quels sont les problèmes actuels dans la gestion des templates ?</p><p>Prenons la complétion de code comme exemple. Considérez le code suivant, où <code>^</code> représente la position du curseur :</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>En C++, si un type dépend de paramètres de template, nous ne pouvons faire aucune supposition précise à son sujet avant l&#39;instanciation du template. Par exemple, ici <code>vector</code> pourrait être soit le template primaire, soit la spécialisation partielle de <code>vector&lt;bool&gt;</code>. Lequel devrions-nous choisir ? Pour la compilation du code, la précision est toujours le plus important — nous ne pouvons utiliser aucun résultat susceptible de conduire à des erreurs. Mais pour les serveurs de langage, fournir plus de résultats possibles est souvent mieux que de ne rien fournir du tout. Nous pouvons supposer que les utilisateurs utilisent le template primaire plus souvent que les spécialisations partielles, et donc fournir des résultats de complétion de code basés sur le template primaire. Actuellement, clangd fait exactement cela — dans le cas ci-dessus, il fournira une complétion de code basée sur le template primaire de <code>vector</code>.</p><p>Considérez un exemple plus complexe :</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vec2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    vec2[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Du point de vue de l&#39;utilisateur, la complétion devrait également être fournie ici, puisque le type de <code>vec2[0]</code> est aussi <code>vector&lt;T&gt;</code>, n&#39;est-ce pas ? Même chose que l&#39;exemple précédent. Mais clangd ne fournira aucune complétion ici. Quel est le problème ? Selon la norme C++, le type de retour de <code>std::vector&lt;T&gt;::operator[]</code> est <code>std::vector&lt;T&gt;::reference</code>, qui est en fait un <a href="https://en.cppreference.com/w/cpp/language/dependent_name" target="_blank" rel="noreferrer">nom dépendant</a>. Son résultat semble assez direct — c&#39;est <code>T&amp;</code>. Mais dans libstdc++, sa définition est imbriquée dans des dizaines de couches de templates, apparemment pour la compatibilité avec les anciennes normes ? Alors pourquoi clangd ne peut-il pas gérer cette situation ?</p><ol><li>Il se base sur des hypothèses de template primaire, sans considérer que les spécialisations partielles pourraient rendre la recherche impossible.</li><li>Il effectue uniquement une recherche de nom sans instanciation de template, donc même s&#39;il trouve le résultat final, il ne peut pas le relier aux paramètres de template originaux.</li><li>Il ne prend pas en compte les paramètres de template par défaut, incapable de gérer les noms dépendants causés par des paramètres de template par défaut.</li></ol><p>Bien que nous puissions faire des exceptions pour les types de la bibliothèque standard afin de fournir un support connexe, je souhaite que le code utilisateur puisse avoir le même statut que le code de la bibliothèque standard, nous avons donc besoin d&#39;un algorithme universel pour gérer les types dépendants. Pour résoudre ce problème, j&#39;ai écrit une pseudo-instanciation (pseudo instantiator). Elle peut instancier des types dépendants sans types spécifiques, atteignant ainsi un objectif de simplification. Par exemple, dans l&#39;exemple ci-dessus, <code>std::vector&lt;std::vector&lt;T&gt;&gt;::reference</code> peut être simplifié en <code>std::vector&lt;T&gt;&amp;</code>, et ainsi fournir des options de complétion de code pour les utilisateurs.</p>`,10)])])}const k=s(n,[["render",l]]);export{u as __pageData,k as default};
