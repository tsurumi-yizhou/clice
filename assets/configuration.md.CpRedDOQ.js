import{_ as t,c as a,o as s,ae as i}from"./chunks/framework.U1Gow_7P.js";const k=JSON.parse('{"title":"Configuration","description":"","frontmatter":{},"headers":[],"relativePath":"configuration.md","filePath":"en/configuration.md"}'),o={name:"configuration.md"};function n(d,e,l,h,r,c){return s(),a("div",null,e[0]||(e[0]=[i(`<h1 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h1><p>This is the document of</p><h2 id="server" tabindex="-1">Server <a class="header-anchor" href="#server" aria-label="Permalink to &quot;Server&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>server.moduleSupport</code></td><td><code>boolean</code></td><td><code>false</code></td></tr></tbody></table><p>Whether to enable module support. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>server.overSearch</code></td><td><code>boolean</code></td><td><code>true</code></td></tr></tbody></table><ul><li><code>false</code>: Limits the symbol search scope to files connected through the <strong>include graph</strong>, which is efficient but does not handle symbols defined independently in other files.</li></ul><p>For example:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// a.h</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// b.cpp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a.h&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Foo foo1;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// c.cpp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a.h&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Foo foo2;</span></span></code></pre></div><p>If you look up the symbol <code>Foo</code> in <code>b.cpp</code>, the include graph guides the search path as follows: <code>b.cpp</code> -&gt; <code>a.h</code> -&gt; <code>c.cpp</code>. All other files are ignored. When you have a really large project, this can save a lot of time.</p><ul><li><code>true</code>: Expands the search to all index files, ignoring the include graph. This is less efficient but ensures all references to a symbol can be found, even if they are not linked through <code>#include</code>.</li></ul><p>For example, consider the following files:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// a.cpp </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Foo foo1;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// b.cpp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> foo2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>In such case, because the symbol <code>Foo</code> is independently declared in multiple files. To find all references to <code>Foo</code>, it becomes necessary to search all index files. <br></p><h2 id="rule" tabindex="-1">Rule <a class="header-anchor" href="#rule" aria-label="Permalink to &quot;Rule&quot;">​</a></h2><p><code>[rules]</code> represents that it is an array of objects. Each object has the following properties. Note that the order of rules matters. clice applies the first matching rule to the file. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th></tr></thead><tbody><tr><td><code>[rules].pattern</code></td><td><code>string</code></td></tr></tbody></table><p>Glob pattern for matching files. If the pattern matches the file path, clice will apply the rule to the file.</p><p>Normally, the pattern is a file path. However, you can also use the following syntax to match multiple files:</p><ul><li><code>*</code>: Matches one or more characters in a path segment.</li><li><code>?</code>: Matches a single character in a path segment.</li><li><code>**</code>: Matches any number of path segments, including none.</li><li><code>{}</code>: Groups conditions (e.g., <code>**/*.{ts,js}</code> matches all TypeScript and JavaScript files).</li><li><code>[]</code>: Declares a range of characters to match in a path segment(e.g., <code>example.[0-9]</code> matches <code>example.0</code>, <code>example.1</code>, etc.).</li><li><code>[!...]</code>: Negates a range of characters to match in a path segment(e.g., <code>example.[!0-9]</code> matches <code>example.a</code>, <code>example.b</code>, but not <code>example.0</code>). <br></li></ul><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].append</code></td><td><code>array</code> of <code>string</code></td><td><code>[]</code></td></tr></tbody></table><p>Commands to append to the original command list. For example, <code>append = [&quot;-std=c++17&quot;]</code>. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].remove</code></td><td><code>array</code> of <code>string</code></td><td><code>[]</code></td></tr></tbody></table><p>Commands to remove from the original command list. For example, <code>remove = [&quot;-std=c++11&quot;]</code>. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].readonly</code></td><td><code>string</code></td><td><code>&quot;auto&quot;</code></td></tr></tbody></table><p>Controls whether the file is treated as readonly. Value could be one of <code>&quot;auto&quot;</code>, <code>&quot;always&quot;</code> and <code>&quot;never&quot;</code>.</p><ul><li><code>&quot;auto&quot;</code>: Treats the file as readonly until you edit it.</li><li><code>&quot;always&quot;</code>: Always treats the file as readonly.</li><li><code>&quot;never&quot;</code>: Always treats the file as non-readonly.</li></ul><p>Readonly means the file is not editable, and LSP requests such as code actions or completions will not be triggered on it. This avoids dynamic computation and allows pre-indexed results to be loaded directly, improving performance. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].header</code></td><td><code>string</code></td><td><code>&quot;auto&quot;</code></td></tr></tbody></table><p>Controls how header files are treated. Value could be one of <code>&quot;auto&quot;</code>, <code>&quot;always&quot;</code> and <code>&quot;never&quot;</code>.</p><ul><li><code>&quot;auto&quot;</code>: Attempts to infer the header context first. If no header context is found, the file will be treated as a normal source file.</li><li><code>&quot;always&quot;</code>: Always treats the file as a header file. If no header context is found, errors will be reported.</li><li><code>&quot;never&quot;</code>: Always treats the file as a source file.</li></ul><p>Header context refers to the related source files or additional metadata linked to the header file. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].contexts</code></td><td><code>array</code> of <code>string</code></td><td><code>[]</code></td></tr></tbody></table><p>Specifies extra header contexts (file paths) for the file.</p><p>Normally, header contexts are inferred automatically once the file is indexed. However, if you need immediate context before indexing completes, you can provide it manually using this field.</p><h2 id="cache" tabindex="-1">Cache <a class="header-anchor" href="#cache" aria-label="Permalink to &quot;Cache&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>cache.dir</code></td><td><code>string</code></td><td><code>&quot;\${workspace}/.clice/cache&quot;</code></td></tr></tbody></table><p>Directory for storing PCH and PCM <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>cache.limit</code></td><td><code>number</code></td><td><code>0</code></td></tr></tbody></table><p>Maximum number of cache files to keep. If the total exceeds this limit, clice deletes the oldest files automatically. Set to <code>0</code> to disable the limit. <br></p><h2 id="index" tabindex="-1">Index <a class="header-anchor" href="#index" aria-label="Permalink to &quot;Index&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>index.dir</code></td><td><code>string</code></td><td><code>&quot;\${workspace}/.clice/index&quot;</code></td></tr></tbody></table><p>Directory for storing index files. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>index.background</code></td><td><code>boolean</code></td><td><code>true</code></td></tr></tbody></table><p>Whether index files in the background. If <code>true</code>, clice will index files in the background when the server is idle. If <code>false</code>, you need to send an index request to index files. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>index.instantiation</code></td><td><code>boolean</code></td><td><code>true</code></td></tr></tbody></table><p>Whether index entities inside template instantiation. For example</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typename</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">template</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>If <code>index.instantiation</code> is <code>true</code>, clice will traverse declarations in template instantiation, such as <code>foo&lt;X&gt;</code> and <code>foo&lt;Y&gt;</code>, and index them. As a result, if you trigger <code>go-to-definition</code> on <code>foo</code> in <code>T::foo()</code>, clice will return the locations of <code>X::foo</code> and <code>Y::foo</code>.</p><p>If <code>index.instantiation</code> is <code>false</code>, clice will not index entities inside template instantiations, and <code>go-to-definition</code> will return no results. <br></p><h2 id="feature" tabindex="-1">Feature <a class="header-anchor" href="#feature" aria-label="Permalink to &quot;Feature&quot;">​</a></h2><h3 id="semantic-tokens" tabindex="-1">Semantic Tokens <a class="header-anchor" href="#semantic-tokens" aria-label="Permalink to &quot;Semantic Tokens&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>feature.semanticTokens.typeMap</code></td><td><code>array</code> of <code>table</code></td><td><code>[]</code></td></tr><tr><td><code>feature.semanticTokens.modifierMap</code></td><td><code>array</code> of <code>table</code></td><td><code>[]</code></td></tr></tbody></table><p>Maps the customized semantic symbol kinds or modifier to LSP semantic token types or modifiers.</p><p>Example:</p><div class="language-toml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">toml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">feature</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">semanticTokens</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">typeMap = [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {&quot;from&quot;: &quot;header&quot;, &quot;to&quot;: &quot;string&quot;},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {&quot;from&quot;: &quot;attribute&quot;, &quot;to&quot;: &quot;decorator&quot;},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">modifierMap = [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {&quot;from&quot;: &quot;const&quot;, &quot;to&quot;: &quot;readonly&quot;},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {&quot;from&quot;: &quot;pureVirtual&quot;, &quot;to&quot;: &quot;abstract&quot;},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>For all clice symbol kinds, please refer to <a href="https://github.com/clice-project/clice/blob/main/include/AST/SymbolKind.h" target="_blank" rel="noreferrer">SymbolKind</a>. The first letter of the name should be translated to lowercase. For all LSP semantic token types, refer to <a href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_semanticTokens" target="_blank" rel="noreferrer">SemanticTokenKind</a>.</p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>feature.semanticTokens.standard</code></td><td><code>boolean</code></td><td><code>false</code></td></tr></tbody></table><p>If <code>true</code>, clice will map the semantic token types and modifiers to the standard ones automatically.</p><h3 id="folding-range" tabindex="-1">Folding Range <a class="header-anchor" href="#folding-range" aria-label="Permalink to &quot;Folding Range&quot;">​</a></h3>`,60)]))}const u=t(o,[["render",n]]);export{k as __pageData,u as default};
