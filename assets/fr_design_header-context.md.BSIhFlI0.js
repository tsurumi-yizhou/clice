import{_ as s,c as i,o as n,ae as a}from"./chunks/framework.l7bN90nj.js";const u=JSON.parse(`{"title":"Contexte d'En-tête","description":"","frontmatter":{},"headers":[],"relativePath":"fr/design/header-context.md","filePath":"fr/design/header-context.md"}`),t={name:"fr/design/header-context.md"};function c(l,e,p,o,d,r){return n(),i("div",null,[...e[0]||(e[0]=[a(`<h1 id="contexte-d-en-tete" tabindex="-1">Contexte d&#39;En-tête <a class="header-anchor" href="#contexte-d-en-tete" aria-label="Permalink to &quot;Contexte d&#39;En-tête&quot;">​</a></h1><p>Pour que clangd fonctionne correctement, les utilisateurs doivent souvent fournir un fichier <code>compile_commands.json</code> (ci-après dénommé fichier CDB). L&#39;unité de compilation de base du modèle de compilation traditionnel du C++ est un fichier source (par exemple, les fichiers <code>.c</code> et <code>.cpp</code>), où <code>#include</code> se contente de copier-coller le contenu des fichiers d&#39;en-tête à la position correspondante dans le fichier source. Le fichier CDB mentionné précédemment stocke les commandes de compilation correspondant à chaque fichier source. Lorsque vous ouvrez un fichier source, clangd utilisera sa commande de compilation correspondante dans le CDB pour compiler ce fichier.</p><p>Naturellement, une question se pose : si le fichier CDB ne contient que des commandes de compilation pour les fichiers sources et non pour les fichiers d&#39;en-tête, comment clangd gère-t-il les fichiers d&#39;en-tête ? clangd traite les fichiers d&#39;en-tête comme des fichiers sources, puis, selon certaines règles, utilise par exemple la commande de compilation d&#39;un fichier source situé dans le même répertoire comme commande de compilation pour cet en-tête. Ce modèle est simple et efficace, mais il ignore certaines situations.</p><p>Puisque les fichiers d&#39;en-tête font partie des fichiers sources, il arrive que leur contenu diffère selon ce qui les précède dans le fichier source. Par exemple :</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.h</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TEST</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ... };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ... };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b.cpp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TEST</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a.h&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// c.cpp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a.h&quot;</span></span></code></pre></div><p>Évidemment, <code>a.h</code> a des états différents dans <code>b.cpp</code> et <code>c.cpp</code> — l&#39;un définit <code>X</code> et l&#39;autre définit <code>Y</code>. Si nous traitons simplement <code>a.h</code> comme un fichier source indépendant, alors seul <code>Y</code> pourra être vu.</p><p>Un cas plus extrême est celui des fichiers d&#39;en-tête non autonomes (non &quot;self-contained&quot;), par exemple :</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.h</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    X x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b.cpp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a.h&quot;</span></span></code></pre></div><p><code>a.h</code> ne peut pas être compilé seul, mais lorsqu&#39;il est intégré dans <code>b.cpp</code>, il se compile normalement. Dans ce cas, clangd signalera une erreur dans <code>a.h</code>, incapable de trouver la définition de <code>X</code>. C&#39;est parce qu&#39;il traite <code>a.h</code> comme un fichier source indépendant. Il existe de nombreux fichiers d&#39;en-tête de ce type dans le code de la libstdc++, et certaines bibliothèques C++ populaires composées uniquement d&#39;en-tête (header-only) utilisent également ce genre de code, que clangd ne peut actuellement pas gérer.</p><p>clice prendra en charge le <strong>contexte d&#39;en-tête</strong>, permettant le basculement automatique ou initié par l&#39;utilisateur des états des fichiers d&#39;en-tête, et supportera bien sûr les fichiers d&#39;en-tête non autonomes. Nous voulons obtenir l&#39;effet suivant, en utilisant le premier exemple de code : lorsque vous passez de <code>b.cpp</code> à <code>a.h</code>, <code>b.cpp</code> est utilisé comme contexte pour <code>a.h</code>. De même, lorsque vous passez de <code>c.cpp</code> à <code>a.h</code>, <code>c.cpp</code> est utilisé comme contexte pour <code>a.h</code>.</p>`,10)])])}const k=s(t,[["render",c]]);export{u as __pageData,k as default};
